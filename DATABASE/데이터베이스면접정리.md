#  데이터 베이스

DBMS : 데이터를 조직화하여 관리 (Management)
Data Base  : 결국 모든 내용이 저장되는 곳은 파일  (물리적으로 저장)
DBMS가 없을 때에는 애플리케이션 파일을 직접 관리 (지금도 직접 할 수 있음)

> 다중 사용자의 동시 접근을 허용하면서 `데이터의 무결성 유지` 


## DBMS 구성 요소

parser : SQL 해석

Optimizer : 최적의 실행방법 결정(**비용기반**,  규칙기반), **PLAN(실행계획)**

	- 어떻게 읽어올지 (인덱스)
	
	- 조인은 어떻게 할지
	
	- 사람의 도움이 필요로 할떄도 있음!
	
Executor : PLAN 실행

	- 실행 순서 : `from -> where -> group by -> having -> select -> order by`
	- ORDER BY 같은걸 하면 **실제로** 메모리에 데이터 때려놓고 정렬을 한다..! => 효율적인 방법이 없을지 비용 생각하며 사용해야함
스토리지 엔진 : **데이터베이스 파일** 관리. 테이블스페이스 등등...

시스템 OR 메타 테이블(뷰) : DBMS 가 관리하는 정보 (사용자, 테이블 목록, 컬럼 목록 등)

## 사용자 입장에서 데이터베이스의 구성 요소
- 테이블
	- 특별하신분(키) : 보통 키 순서를 유지한다(정렬되어있다)
	- 나머지 : 컬럼
- 뷰 : 저장되어있는 SELECT
- 트리거
- 인덱스
- 제약조건(Constraints) : FK도 Constraints (업체마다 다르지만 일부러 FK 안사용하는 업체가 더 많다) , Unique, Not Null ... 
- 내장함수 : NVL, SUBSTR, TO_DATE,...
- 사용자 정의 함수와 프로시저 (Stored Procedure)
- 사용자, 네임스페이스(스키마)
- 시퀀스, 시노님(synonym, alias)
- 세션 : `트랜잭션과` 깊은 연관, 커밋하기 전까지 나한테만 이렇게 보이고 다른사람들한테는 다르게 보일 수 있다(ISOLATION LEVEL_
	- 이것을 볼 수 있는 뷰가 있음

## 트랜잭션
- 다중 사용자 상황에서 원자성, 무결성을 위한 **DBMS 핵심 기능**
- 커밋은 어떻게 이루어지는가
- 롤백은 어떻게 이루어지는가
- `WAI(Write Ahead Log)` : 로그 선행 기입- 트랜잭션 구현하는데 중요한 기능
- 트랜잭션은 `lock(락)`을 발생시킬 수 있기 때문에 가급적 짧아야 함
	- 행 수준(Row Level)
	- 테이블 수준(Table Level) : 테이블 락이 걸리면 큰일이 나기도 한다..!
	- 락의 종류에 따라 사용자마다 다른 데이터를 볼 수 도 있다(위에 세션) 

## 인덱스
- 보다  빠르게 검색(SELECT) 하기 위한 용도 -> 테이블에 모든 데이터를 살펴보고 찾아오는건 비효율적
- 인덱스를 위한 별도의 저장 공간 필요(저장용량 도 필요해지고 CUD 비용 커짐)
	- PK(인덱스로 기능할 수 있음)의 경우 아예 PK 순서대로 저장하기도 함
- 정렬되어있음(인덱스 생성할 때 옵션을 줄 수도 있다!)
- 검색 조건으로 자주 사용되는 컬럼들을 별도의 인덱스로 지정
- 보통 B Tree  자료구조 사용
- 풀스캔 : 테이블 다 로드해서 읽기 -> 옵티마이저의 최후의 선택
- 레인지 스캔 : 인덱스에 걸린 애들만
- 인덱스 유니크 스캔 : 딱 그 행만..
- 대부분 인덱스를 타도록 하는게 좋지만 아닌 경우도 있음(인덱스 타는게 더 느린 경우도..)
- 인덱스가 있지만 안타는 경우도 있다(해당 컬럼에 함수 걸거나, 혼합키에서 중간 컬럼  빼놓은거 등) -> 종종 실수하는 부분. PLAN을 보면 나온다
- 힌트 : 옵티마이저가 인덱스를 잘 선택하도록 도와주기

## 정규화, 반정규화
- 정규화(Normalization) : 1차 (1st Normalization), 2차(2NF), 3차 , BCNF, 4차, 5차
	- 1차(속성 = 컬럼은 ***하나**의 값/ 속성값 중복 제거), 2차(**식별자**에 종속되지 않는 속성의 중복 제거), 3차(2차 + **식별자 외 컬럼**간의 종속 제거)
	- 보통 데이터의 특징을 살리고 `중복을 줄이는` 방향으로 진행됨(하나의 데이터에는 딱  한곳에만 존재). 대신 ㅌ테이블이 나누어지게 되므로 테이블 숫자가 많아짐(relational)
	- RDB의 특징을 살리는 `설계방안`. 대부분의 경우 정규화를 지키느ㅡㄴ게 맞지만 필요에 따라 일부러 깨기도 한다 -> `역정규화`
- 반정규화(Denormalization) : 정규화를 일부러 깨는 것
	- 보통 `성능` 때문에.. => **여러 테이블의 조인** 때문에 느려져서 => 테이블 합치기 or 컬럼 중복시키자(한번에 읽을 수 있게)
		- SELECT 비용과 INSERT/DELETE/UPDATE 비용은 다르다. INSERT하기 좋은 테이블 설계 VS SELECT 하기 좋은 테이블 설계
		- 중복된 데이터가 서로 달라질 수 있다 => `무결성`이 깨질 수 있다
	- 필요해서 -> 데이터 뭉쳐서 한 컬럼에 (1NF 위반) 넣기 등등


## 흔한 면접 질문들

### RDBMS
	1. 간단한  SQL(테이블 주고 해보기?)
	2. 조회 심화 : 각종 JOIN, GROUP BY/HAVING, AGGREGATE
	3. 조회 심화2(안물어볼듯) : Partition by, Start with/Connect by 계층형(자기참조 테이블)
	4. ACID와 트랜잭션, 커밋, 롤백, 락, ... : 제일 중요한 기능
		Atomicitty : 모두 성공적으로 실행되던지 안되던지
		Consistency : 무결성 제약 등
		Isolation : 다른 트랜잭셩에 영향 x
		Durability : 영구적으로 저장
	5. DCL, DML, DDL,TCL(Transaction Control)
	6. 타입? CHAR, VARCHAR, DATE, DATETIME, TIMESTAMP, TEXT, CLOB, BLOB, etc
	7. ORM : JPA
	8. ERD 읽기
	9. 어떤 DB를 써보았나 ? -> 로컬에서는 sqlite(h2나 hsqldb)를 사용했고 테스트와 운영 환경에서는 MYSQL/mariaDB를 써봤습니다
	10. 테이블 설계 겅험
	11. `클러스터 인덱스 `,` 넌클러스터 인덱스` : 자주 질문
	12. Master-Slave, Clustering,  Sharding, Migration
	13. NoSQL
		- 정의
		- CAP Theorem
		- 어떤게 있나 : Document, Key-value store, hybrid, graph, time series 등등
		- 어떤 용도로 많이 사용하나 : 케싱,  설정 데이터(호ㅓㅏㄴ경변수( 공유, 비정형 데이터(게시판 댓글 등) 저장, 채팅, 로그 저장, 매트릭 저장 등
	14. 이론적 지식 배경 : 집합론, 관계 대수(Codd)
